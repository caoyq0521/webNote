# 位运算

**位运算符是在数字底层（即表示数字的 32 个数位）进行操作的。**

## 位运算 NOT

**位运算 NOT 由否定号 `~` 表示，它是ECMASript中为数不多的与二进制有关的运算符之一。**

位运算 NOT 是三步处理过程：

* 把运算数转换成32位数字
* 把二进制数转换成它的二进制转码
* 把二进制数转换为浮点数

````js
let num1 = 25;  //25 等于 00000000000000000000000000011001
let num2 = ~num1;  //转换为 11111111111111111111111111100110
console.log(num2);  // -26
````

位元算 NOT 实质上是对数字求负，然后减1，因此 25 变 -26。用下面的方法也可以得到同样的结果：

````js
let num1 = 25;
let num2  = -num1 - 1;
console.log(num2);  // -26
````

##  位运算 AND

**位运算 AND 由和号 `&` 表示，直接对数字的二进制形式进行运算。它把每个数字中的数位对齐，然后用下面的规则对同一位置上的两个数位进行 AND 运算：**

| 第一个数字中的数位 | 第二个数字中的数位 | 结果
| :--: | :--: | :--:
| 1 | 1 | 1
| 1 | 0 | 0
| 0 | 1 | 0
| 0 | 0 | 0


````js
/* 要对数字 25 和 3 进行 AND 运算 */
let result = 25 & 3;
console.log(result);  // 1

/* 分析如下 */

 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001

可以看出，在 25 和 3 中，只有一个数位（位 0）存放的都是 1，因此，其他数位生成的都是 0，所以结果为 1。
````

## 位运算 OR

**位运算 OR 由符号 `|` 来表示，直接对数字的二进制形式进行运算。在计算每位时，OR 运算符采用下列规则：**

| 第一个数字中的数位 | 第二个数字中的数位 | 结果
| :--: | :--: | :--:
| 1 | 1 | 1
| 1 | 0 | 1
| 0 | 1 | 1
| 0 | 0 | 0

````js
/* 对 25 和 3 进行 OR 运算 */
let result = 25 | 3;
console.log(result);  // 27

/* 分析如下 */

25 = 0000 0000 0000 0000 0000 0000 0001 1001
 3 = 0000 0000 0000 0000 0000 0000 0000 0011
--------------------------------------------
OR = 0000 0000 0000 0000 0000 0000 0001 1011

可以看出，在两个数字中，共有 4 个数位存放的是 1，这些数位被传递给结果。二进制代码 11011 等于 27。
````

## 位运算 XOR

**位运算 XOR 由符号 `^` 来表示，直接对数字的二进制形式进行运算。XOR 不同于 OR，当只有一个数位存放的是 1 时，它才返回 1。真值表如下：**

| 第一个数字中的数位 | 第二个数字中的数位 | 结果
| :--: | :--: | :--:
| 1 | 1 | 0
| 1 | 0 | 1
| 0 | 1 | 1
| 0 | 0 | 0

````js
/* 对 25 和 3 进行 XOR 运算 */
let result = 25 ^ 3;
console.log(result);  // 26

/* 分析如下 */

25 = 0000 0000 0000 0000 0000 0000 0001 1001
 3 = 0000 0000 0000 0000 0000 0000 0000 0011
--------------------------------------------
XOR = 0000 0000 0000 0000 0000 0000 0001 1010

可以看出，在两个数字中，共有 4 个数位存放的是 1，这些数位被传递给结果。二进制代码 11010 等于 26。
````

## 左移运算

**左移运算由两个小于号 `<<` 来表示。他把数字中的所有所有数位向左移动指定数量。**

````js
/* 把数字 2 左移 5 位，结果为 64 */
let oldNum = 2; // 等于二进制中的 10
let newNum = oldNum << 5;  // 等于二进制中的 1000000
console.log(newNum);  // 64
````

* 注意：在左移数位时，数字右边多出 5 个空位。左移运算用 0 填充这些空位，使结果成为完整的 32 位数字。

![示例图片](https://www.w3school.com.cn/i/ct_js_operators_bitwise_leftshift.gif)

* 注意：左移运算保留数字的符号位。例如，如果把 -2 左移 5 位，得到的是 -64，而不是 64。“符号仍然存储在第 32 位中吗？”是的，不过这在 ECMAScript 后台进行，开发者不能直接访问第 32 个数位。即使输出二进制字符串形式的负数，显示的也是负号形式（例如，-2 将显示 -10。）

## 有符号右移

**有符号右移由两个大于符号 `>>` 来表示。来表示。他把数字中的所有所有数位向右移动指定数量。同时保留该数的符号（正号或负号）。有符号右移运算符恰好与左移运算相反。**

````js
/* 把 64 右移 5 位，将变为 2 */
let oldNum = 64;  //等于二进制 1000000
let newNum = oldNum >> 5;  //等于二进制 10 十进制 2
console.log(newNum);  // 2
````

* 注意：移动数位后会造成空位。这次，空位位于数字的左侧，但位于符号位之后。ECMAScript 用符号位的值填充这些空位，创建完整的数字，如下图所示：

![示例图片](https://www.w3school.com.cn/i/ct_js_operators_bitwise_signedrightshift.gif)

## 无符号右移运算

**无符号右移运算符由三个大于号 `>>>` 表示，它将无符号 32 位数的所有数位整体右移。**

* 对于正数，无符号右移运算的结果与有符号右移运算一样。
<br>
    ````js
    /* 把 64 右移 5 位，将变为 2 */
    let oldNum = 64;		//等于二进制 1000000
    let newNum = oldNum >>> 5;	//等于二进制 10 十进制 2
    console.log(newNum);  // 2
    ````
<br>

* 对于负数，情况就不同了。

````js
无符号右移运算用 0 填充所有空位。对于正数，这与有符号右移运算的操作一样，而负数则被作为正数来处理。
由于无符号右移运算的结果是一个 32 位的正数，所以负数的无符号右移运算得到的总是一个非常大的数字。

例如，如果把 -64 右移 5 位，将得到 134217726。如何得到这种结果的呢？
要实现这一点，需要把这个数字转换成无符号的等价形式（尽管该数字本身还是有符号的），可以通过以下代码获得这种形式：

let iUnsigned64 = -64 >>> 0;

然后，用 Number 类型的 toString() 获取它的真正的位表示，采用的基为 2：

console.log(iUnsigned64.toString(2));

这将生成 11111111111111111111111111000000，即有符号整数 -64 的二进制补码表示，不过它等于无符号整数 4294967232。
出于这种原因，使用无符号右移运算符要小心。
````

[深入讲解js中的位运算及实际用法](https://segmentfault.com/a/1190000019826036)